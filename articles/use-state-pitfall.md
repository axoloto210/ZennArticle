---
title: "useStateの落とし穴を避ける"
emoji: "🪄"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [React, TypeScript, JavaScript]
published: true
---
## コンポーネントに値を紐づける`useState`
React でコンポーネントに値を保持しておきたい時に`useState`というhooks がよく使われます。
この`useState`から渡される`state`を通常の変数のように扱うと、思ったように値が更新されなかったり、なぜか値のリセットがかかってしまったりと落とし穴に嵌ってしまうことがしばしばあります。
そんな`useState`がどのような仕組みで値の保持、更新を行っているのかを見ていきたいと思います。
## `useState`とは
`useState`はコンポーネントが保持する値である`state`と、`state`に変更をかけるためのset関数を提供します。
```ts
const [num setNum] = useState(0)
```
上のコード例のように`useState`の引数に`state`の初期値を渡して（省略した場合のデフォルト値は`undefined`）呼び出すことで、`state`とset関数がタプル型で返されます。（`[state, setState]`部分では配列の分割代入によって値を受け取っています。）
`state`の値を更新するには`setState`に更新したい値を渡します。
`setState`には更新用の関数を渡すこともでき、更新用関数は引数としてその時点での`state`の値を（React側から）受け取ります。
```ts
setNum(((n) => n + 1))
```
## なぜ`useState`が必要なのか
`useState`を使用せず、`let`や`const`などによってローカル変数を用意して管理すれば良いようにも思えますが、Reactでは画面内容を更新する際にレンダーとよばれるプロセスを経るため、ローカル変数がレンダー間で保持されずリセットされてしまい、ローカル変数をコンポーネントにうまく紐づけることができません。レンダー間でコンポーネントの値を保持するために`useState`が必要になるわけです。
### そもそもレンダーとは
Reactにおけるレンダーとは、**React がコンポーネントを呼び出すこと**です。
（コンポーネントを呼び出して仮想のDOMツリーを作成し、現在のDOMツリーとの差分を検証、差分のあった箇所のみDOMツリーを変更します。）
親コンポーネントからの`props`が変化したときや、`forceUpdate()`がよびだされたとき、`setState`によって`state`が更新されるときなどにレンダーの実行命令がキューに追加されます。
コンポーネントに値を紐づけるためにコンポーネント内部でローカル変数を宣言しても、レンダー時にコンポーネントが呼び出され、ローカル変数も新たに作成されるためリセットがかかってしまうわけですね。
https://ja.react.dev/learn/render-and-commit
## 落とし穴１：`useState`で値をセットしてもすぐに`state`が更新されない？

@[stackblitz](https://stackblitz.com/edit/stackblitz-starters-wofwch?embed=1&file=src%2FApp.tsx)
上のコード例では、set関数を２回実行しています。
set関数をstate変数への値の代入と捉えると、１度目の実行箇所`setNum(num + 1)`で`num`の値は1となり、2度目の実行箇所`setNum(num + 2)`で`num`の値は3となるように思えますが、実際にボタンを押してみると2ずつ加算されていきます。
これは、set関数はstateの値を変更しているのではなく、次のレンダー時のstateの値を変更する命令をキューに追加していることに起因しています。
キューに追加された`state`値の変更命令をすべて処理して次のレンダーでの`state`値を決定します。
### set関数は次回レンダー時の`state`値を設定する
`useState`が返す`state`値は、初回レンダー時は`useState`に渡した引数となり、それ以降のレンダー時は（前回のレンダー時に）set関数によって設定された値が返されます。
**set関数は次回レンダー時の`state`値を設定する関数であり、`state`値はそのレンダーの間は変化しない値**なのです。
複数のset関数によって値が設定される場合には、それらの設定処理をすべて行った後の値が次回レンダー時に`state`値として返されます。

先ほどのコード例では以下のように２回set関数を実行していました。
```ts
  const clickHandler = () => {
    setNum(num + 1);
    setNum(num + 2);
  };
```
これは「このレンダー時点でのstate値`num`に1を足した値を設定」した後に「このレンダー時点でのstate値`num`に2を足した値を設定」するため、最終的には次のレンダー時のstate値として`num + 2`が設定されることとなります。
このように処理がされるため、ボタンを押した後に画面に表示される値が`num + 3`にならなかったわけですね。
https://ja.react.dev/learn/state-as-a-snapshot
### 更新関数を渡すことで落とし穴を回避
レンダー時点の`state`値を使うのではなく、その処理を行っている時点での値を使用したい場合には、変数を別で用意しておいて、処理をしてからset関数に渡すことで解決できます。
これをより簡潔に行う方法として、**set関数に更新用の関数を渡す**方法があります。
`setNum((n)=> n + 1)`のようにすることで、次のレンダー時に渡される予定の`state`値を引数`n`で受け取ることができ、返り値`n+1`が新たに次のレンダー時のstate値として設定されます。

この方法を用いることで、先のコード例は次のように書き換えられます。
@[stackblitz](https://stackblitz.com/edit/stackblitz-starters-do9pfl?embed=1&file=src%2FApp.tsx)
ボタンをクリックすることで、3ずつ値が加算されて表示されるようになったと思います。

### `setState`は次回レンダー時の`state`値を決めるキューに更新命令を追加している
stateの変更が複数回発生した場合には、一つずつレンダーを行うのではなく、一度にまとめて行われます（クリックのような意図的なイベントが複数回発生した場合など例外あり）。
先のコード例では１つ目のキュー`setNum((n)=> n + 1)`と2つ目のキュー`setNum((n)=> n + 2)`による処理が、現時点のレンダー時の`state`の値（`useState`から返されている値）に対して行われます。
`setNum(num + 1)`なども`setNum((n) => num + 1)`というように更新関数が渡されていると捉えることができ、`setNum(num + 1)`の後に`setNum(num + 2)`を実行すると、１つ目のキュー`setNum(num + 1)`でどんな値を設定しても次のキューでその値が使われていないため、あたかもなかったかのように処理が進んでしまうわけですね。
https://ja.react.dev/learn/queueing-a-series-of-state-updates


## 落とし穴２：set関数を使用したのに画面が更新されない？
通常、set関数によって次回レンダー時の`state`値を設定することで再レンダーが起こります。
しかし、以下のような場合には再レンダーが起こりません。
@[stackblitz](https://stackblitz.com/edit/stackblitz-starters-gsupdn?file=src%2FApp.tsx)
ボタンをクリックしてみると、console上では確かに`initialObj`と`state`の`num`プロパティの値は共に変化していますが、画面上の値は123のままです。
原因は、set関数の引数として渡した値`initialObj`が前回のレンダー時の値から変化しておらず、レンダーの実行命令が追加されなかったことです。
### set関数は`object.is()`によって、stateの変化を検知する
set関数は`state`が前回のレンダー時から変化しているかどうかを、`Object.is()`によって判別しています。
https://ja.react.dev/reference/react/useState#:~:text=state%20%E3%81%AE%E5%90%8C%E4%B8%80%E6%80%A7%E3%81%AE%E6%AF%94%E8%BC%83%E3%81%AF%E3%80%81Object.is%20%E3%81%AB%E3%82%88%E3%81%A3%E3%81%A6%E8%A1%8C%E3%82%8F%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82

`Object.is()`は厳密等価演算子`===`とほとんど同じ判定をしますが、`0`と`-0`を一致と判定しない点と、`NaN`同士を一致判定する点が異なります。

先の例では`initialObj`のプロパティの値は変化していましたが、stateが変化しているとは検知されず、再レンダーされていませんでした。
変数`initialObj`に格納されているのはオブジェクトへの参照（オブジェクトが格納されているメモリのアドレスのこと）であり、プロパティ値が変化したとしても参照自体は変化しないため、stateが変化したと検知されなかったわけですね。
### 新しいオブジェクトを作成して落とし穴を回避
受け取ったstateと同じオブジェクトのプロパティ値を変更しても変化が検知されませんので、新しいオブジェクトを作成することで検知できるようにします。
スプレッド構文とプロパティ値の上書きを利用することで、stateの変更を読み手にも見やすい形で記述することができます。
@[stackblitz](https://stackblitz.com/edit/stackblitz-starters-u39uav?embed=1&file=src%2FApp.tsx)

## 余談：`useState`はなぜループや条件式、ネストされた関数で使えないのか？
`useState`などのhookはループや条件分岐、ネストされた関数で呼び出すとエラーが発生します。なぜこのような制約が課されているのでしょうか？
理由は、コンポーネント内のhookを**呼び出されている順番**によって識別しているためです。
ループや条件分岐があるとhookが呼び出される順番が、コンポーネントのレンダー間で異なってしまう可能性があるため、これらの機能でのhook呼び出しが制限されているわけです。
https://ja.react.dev/learn/state-a-components-memory#how-does-react-know-which-state-to-return
https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e

